@charset "UTF-8";
@use "sass:string";
@use "sass:meta";
@use "sass:math";
@use "sass:map";
@use "sass:list";

@import './lists/list-of-directions';
@import './lists/list-of-layers';

@import './properties/aspect-ratios';
@import './properties/borders';
@import './properties/breakpoints';
@import './properties/color-palette';
@import './properties/easing';
@import './properties/animations';
@import './properties/shadows';
@import './properties/sizes';
@import './properties/typography';
@import './properties/tokens';

@import './maps/map-for-borders';
@import './maps/map-for-breakpoints';
@import './maps/map-for-flexbox';
@import './maps/map-for-font-weights';
@import './maps/map-for-font-sizes';
@import './maps/map-for-colors';
@import './maps/map-for-directions';
@import './maps/map-for-laptops';
@import './maps/map-for-letterspacing';
@import './maps/map-for-lineheights';
@import './maps/map-for-pc';
@import './maps/map-for-shadows';
@import './maps/map-for-sizes';
@import './maps/map-for-phones';
@import './maps/map-for-tablets';

@import './utilities/clear-unit';
@import './utilities/clear-whitespace';
@import './utilities/convert-to-em';
@import './utilities/convert-to-number';
@import './utilities/darken';
@import './utilities/font-source';
@import './utilities/is-color';
@import './utilities/is-number';
@import './utilities/is-time';
@import './utilities/lighten';
@import './utilities/map-deep-get';
@import './utilities/null';
@import './utilities/pixelify';
@import './utilities/pseudo-selector';
@import './utilities/remify';
@import './utilities/shorthand-property';
@import './utilities/string-to-number';
@import './utilities/validate-breakpoint';
@import './utilities/validate-length';
@import './utilities/validate-scissors';

@import 'functions/color-mixer';
@import 'functions/layer';
@import 'functions/em';

@import './library/absolute';
@import './library/animation';
@import './library/breakpoint-landscape';
@import './library/breakpoint';
@import './library/except';
@import './library/fixed';
@import './library/flex';
@import './library/hide';
@import './library/laptop';
@import './library/loadify';
@import './library/flow';
@import './library/only';
@import './library/pc';
@import './library/phone';
@import './library/remove';
@import './library/screen-agent';
@import './library/size';
@import './library/tablet';
@import './library/text-shadow';
@import './library/text-stroke';

// WIP
@import 'map-keys';
@import 'map-for-ratios';
@import 'scalable-system';
@import 'remove-unit';
@import './utilities/string-replace';
@import 'number-slice';
@import 'list-slice';
@import 'list-reverse';
@import 'map-for-suffixes';


$list-s    : (1rem, 2, 3rem, 4.5);


//
@function __get-value($base, $ratio, $preserve, $i, $variable-prefix: null, $variable-suffix: null) {
	@if ($preserve >= $i) {
		$get-number : __scalable-system($base, $ratio, $preserve, $i, $variable-prefix);
		$sliced-number : __number-slice($get-number);
		$number : $sliced-number;

		@return $number;
	} @else if ($preserve + 1 == $i) {
		$get-number : __scalable-system($base, $ratio, $preserve, $i, $variable-prefix);
		$number : $get-number;

		@return $number;
	} @else {

		@return calc(var(--#{$variable-prefix}#{$variable-suffix}) * var(--ratio));
	}
}

/** WIP
 * Returns scaled value of `$number`.
 *
 * @author - Martin Kamír
 *
 * @example
 * __scale-number(1rem, 50%) => 0.5rem;
 * __scale-number(1rem, 150) => 1.5rem;
 * @overload __scale-number($number, $scale: 100%)
 * @param $number {number} - The number that is being scaled. Accepts only numbers with rem unit or no unit.
 * @param $decrease {number} - Value that is being scaled by. Accepts only numbers with % unit or no unit.
 * @return scaled number
 */
@function __scale-number($number, $scale: 100%) {

	// Checks if `$scale` is not number
	@if (meta.type-of($scale) != 'number') {
		@error 'Value of `$scale` must be a number.';
	}

	// Checks if `$number` is not number
	@if (meta.type-of($number) != 'number') {
		@error 'Value of `$number` must be a number.';
	}

	// Checks if `$scale` have `%` as unit or is `unitless`
	@if (math.unit($scale) != '%') {
		@error 'Value of `$scale` must have `%` as unit.';
	}

	// Checks if value of `$scale` is less than `0`
	@if ($scale < 0) {
		@error 'Parameter `$scale` holds value `#{$scale}`. Value must be greater than `0`.';
	}

	$scale : __remove-unit($scale, '%'); // Remove unit `%` from `$scale`
	$number : math.div($number, 100) * $scale; // Calculates new value of `$number`

	@return $number; // Returns new value of `$number`.
}

/**
 * Returns `$list` of corresponding suffixes. Based on `$set-suffix`.
 *
 * NOTE: This is helper function for function `__get-suffix-list`.
 *
 * @author - Martin Kamír
 *
 * @example
 * __get-suffix-list('size-x-minmax', (1rem, 2rem, 3rem, 4rem, 5rem), $minmax: true) => (min, s, m, l, max);
 * __get-suffix-list('size-x', (1rem, 2rem, 3rem, 4rem, 5rem)) => (xs, s, m, l, xl);
 * __get-suffix-list('size-minmax', (1rem, 2rem, 3rem, 4rem, 5rem), $minmax: true) => (min, small, medium, large, max);
 * @overload __get-suffix-list($set-suffix, $set-list-of-values, $minmax: false)
 * @param $set-suffix {string} - Name of the set suffix that will be used in outputting the suffix. Which is originally called from main `@mixin` as `suffix` parameter.
 * @param $set-list-of-values {list} - List of values that are being used for generating. Which is originally called from main `@mixin` as `$custom-sizes` parameter.
 * @param $minmax {boolean} - As default set to false. If set to true, suffixes will be generated for `min` and `max` values.
 * @return list of suffixes
 */
@function __get-suffix-list($set-suffix, $length, $minmax: false) {
	// Get higher and lower suffixes list from map for suffixes
	$get-lower-list : map.get($map-for-suffixes, $set-suffix, lower-values);
	$get-higher-list : map.get($map-for-suffixes, $set-suffix, higher-values);


	// Get the minimum and maximum index by
	// 1. Getting the length of the list
	// 2. Dividing the length of list by half
	// 3. For the minimum index ceil the number up to the next integer. For the maximum index floor the number down to the next integer
	$min-index : math.ceil(math.div($length, 2));
	$max-index : math.floor(math.div($length, 2));

	// Slice the list to get the minimum and maximum values
	$lower-list : __list-slice($get-lower-list, $end : $min-index);
	$higher-list : __list-slice($get-higher-list, $end : $max-index);


	// If `$minmax` is true, add `min` and `max` values to the list
	@if ($minmax == true) {
		$lower-list : list.set-nth($lower-list, -1, 'min');
		$higher-list : list.set-nth($higher-list, -1, 'max');
	}

	// Concatenate the lower and higher list.
	// The lower list will be at the beginning of the list. That is |why we need to reverse the lower list.
	// The higher list will be at the end of the list.|
	$list : list.join(__list-reverse($lower-list), $higher-list);

	@return $list; // Return the list of suffixes
}

/**
 * Returns string or number(as string) of suffix based on current `$i`, which have to corresponding with `$set-suffix`.
 *
 * @author - Martin Kamír
 *
 * @example
 * __get-suffix(numeric, (1rem, 2.2rem, 2.5rem, 4rem, 5rem), 2.2rem, 2) => 2;
 * __get-suffix(numeric-hundreds, (1rem, 2.2rem, 2.5rem, 4rem, 5rem), 2.2rem, 2) => 200;
 * __get-suffix(hard-suffix, (1rem, 2.2rem, 2.5rem, 4rem, 5rem), 2.5rem, 3) => 2-5;
 * __get-suffix((1A, 2A, 3A, 4A, 5A, 6A), (1rem, 2.2rem, 2.5rem, 4rem, 5rem), 4rem, 4) => 4A;
 * __get-suffix(roman, (1rem, 2.2rem, 2.5rem, 4rem, 5rem), 2.5rem, 3) => III;
 * __get-suffix(size, (1rem, 2rem, 3rem, 4rem, 5rem), 3rem, 3) => medium;
 * __get-suffix(size-x-minmax, (1rem, 2rem, 3rem, 4rem, 5rem), 1rem, 1) => min;
 * __get-suffix(size-and-number, (1rem, 2rem, 3rem, 4rem, 5rem), 1rem, 1) => small-2;
 * __get-suffix(size-and-x, (1rem, 2rem, 3rem, 4rem, 5rem), 5rem, 5) => big-xl;
 *
 * @overload __get-suffix($set-suffix: 'numeric', $set-list-of-values, $hard-suffix, $i)
 *
 * @param $set-suffix {string} - As default set to `numeric`.
 * It is name of the set suffix that will be used in outputting the suffix.
 * Which is originally called from main `@mixin` as `suffix` parameter.
 *
 * @param $set-list-of-values {list} - List of values that are being used for generating.
 * Which is originally called from main `@mixin` as `$custom-sizes` parameter.
 *
 * @param $hard-suffix {number} - The actual value based on current index in loop which is generated. The value will be used as suffix so it is hard coded value/suffix.
 * @param $i {number} - The current index in loop.
 * @return string suffix
 */
@function __get-suffix($set-suffix: 'numeric', $length, $hard-suffix, $i) {

	@if ($set-suffix == 'numeric') {
		@return $i; // Returns the current number based on the index

	} @else if ($set-suffix == 'numeric-hundreds') {
		@return $i + '00'; // Returns the current number based on the index and adds `00` to the end

	} @else if ($set-suffix == 'hard-suffix') {
		@if ($hard-suffix == 'none') {
			@error 'Hard suffix is only allowed when using parameter `$custom-values` as list at mixin NECO.';
		}

		// Remove `unit` from `number` and replace `.` with `-`. Because `.` is not allowed in class names
		$suffix : __string-replace(__string-replace($hard-suffix, 'rem'), '.', '-');
		@return $suffix;

	} @else if (meta.type-of($set-suffix) == 'list') {
		// Checks if `$set-suffix` is list. Which means that is custom suffixes list
		@return list.nth($set-suffix, $i); // Returns suffix from list based on current `$i` in loop

	} @else if (list.index(('roman', 'greek', 'military', 'planets', 'nato', 'alphabet', 'alphabet-upper', 'primary'), $set-suffix)) {
		// Get corresponding suffix list based on `$set-suffix`
		$list-of-suffixes : map.get($map-for-suffixes, $set-suffix);

		@return list.nth($list-of-suffixes, $i); // Returns suffix from list based on current `$i` in loop
	} @else if (list.index(('size', 'size-minmax', 'size-shorted', 'size-shorted-minmax', 'size-x', 'size-x-minmax', 'size-gradation', 'size-gradation-minmax', 'size-and-number', 'size-and-number-minmax', 'size-and-x', 'size-and-x-minmax'), $set-suffix)) {

		// Map which holds corresponding suffixes for `size scaling`
		$map-of-suffixes : (
				'size' : __get-suffix-list($set-suffix, $length),
				'size-minmax' : __get-suffix-list($set-suffix, $length, $minmax : true),
				'size-shorted' : __get-suffix-list($set-suffix, $length),
				'size-shorted-minmax' : __get-suffix-list($set-suffix, $length, $minmax : true),
				'size-x' : __get-suffix-list($set-suffix, $length),
				'size-x-minmax' : __get-suffix-list($set-suffix, $length, $minmax : true),
				'size-gradation' : __get-suffix-list($set-suffix, $length),
				'size-gradation-minmax' : __get-suffix-list($set-suffix, $length, $minmax : true),
				'size-and-number' : __get-suffix-list($set-suffix, $length),
				'size-and-number-minmax' : __get-suffix-list($set-suffix, $length, $minmax : true),
				'size-and-x' : __get-suffix-list($set-suffix, $length),
				'size-and-x-minmax' : __get-suffix-list($set-suffix, $length, $minmax : true)
		);

		// Loop over map and check if `$set-suffix` corresponding with `$key-suffix`
		@each $key-suffix, $list-of-suffixes in $map-of-suffixes {
			@if ($set-suffix == $key-suffix) {
				@return list.nth($list-of-suffixes, $i); // Returns suffix from list based on current `$i` in loop
			}
		}
	} @else {
		@error 'Invalid suffix type of #{$set-suffix}. Valid types are: #{__map-keys($map-for-suffixes)}';
	}
}

@function __set-suffix($set-suffix, $set-specified-suffix, $length, $hard-suffix, $i) {
	@if ($set-specified-suffix != null) {
		@return __get-suffix($set-specified-suffix, $length, $hard-suffix, $i);
	} @else {
		@return __get-suffix($set-suffix, $length, $hard-suffix, $i);
	}
}

@function __set-prefix($set-prefix, $set-specified-prefix) {
	@if ($set-specified-prefix != null) {
		@return $set-specified-prefix;
	} @else {
		@return $set-prefix;
	}
}

@mixin __variable-body($prefix, $suffix, $value) {
	--#{$prefix}#{$suffix} : #{$value};
}

@mixin __declaration-body($prefix, $suffix, $selector: 'font-size') {
	#{$selector} : var(--#{$prefix}#{$suffix});
}

@function __class-body($prefix, $suffix,) {
	@return #{$prefix}#{$suffix};
}

@mixin __prefix-errors($prefix) {
	@if (meta.type-of($prefix) != string) {
		@error 'Parameter `$prefix`, `$prefix-class`, `$prefix-variable` at mixin NECO, must be a type of string';
	} @else if (string.length($prefix) < 1) {
		@error 'Parameter `$prefix`, `$prefix-class`, `$prefix-variable` at mixin NECO must be atleast one character or more.';
	}
}

@mixin __suffix-errors($suffix) {
	@if (meta.type-of($suffix) != list and meta.type-of($suffix) != string) {
		@error 'Parameter `$suffix`, `$suffix-class`, `$suffix-variable` at mixin NECO, must be a type of string';
	} @else if (meta.type-of($suffix) == string and string.length($suffix) < 1) {
		@error 'Parameter `$suffix`, `$suffix-class`, `$suffix-variable` at mixin NECO must be atleast one character or more.';
	}
}

@mixin __length-errors($length) {
	$LENGTH_MAX_LIMIT : 40;
	$LENGTH_MIN_LIMIT : 1;

	@if (meta.type-of($length) != number) {
		@error 'Parameter `$length` at mixin NECO, must be a type of number';
	} @else if ($length > $LENGTH_MAX_LIMIT) {
		@error 'Parameter `$length` holds value of `#{$length}` at mixin NECO. Value must be less or equal than #{$LENGTH_MAX_LIMIT}.';
	} @else if ($length < $LENGTH_MIN_LIMIT) {
		@error 'Parameter `$length` holds value of `#{$length}` at mixin NECO. Value must be greater than #{$LENGTH_MIN_LIMIT}.';
	} @else if (math.is-unitless($length) != true) {
		@error 'Parameter `$length` at mixin NECO, must be a unitless number';
	} @else if (math.round($length) != $length) {
		@error 'Parameter `$length` holds value of `#{$length}` at mixin NECO. Value must be an integer.';
	} @else if ($length == 1) {
		@warn 'Parameter `$length` holds value of `#{$length}` at mixin NECO. Value of 1 is not recommended.';
	}
}

@mixin __preserve-errors($preserve, $length) {
	@if (meta.type-of($preserve) != number) {
		@error 'Parameter `$preserve` at mixin NECO, must be a type of number';
	} @else if (math.is-unitless($preserve) != true) {
		@error 'Parameter `$preserve` at mixin NECO, must be a unitless number';
	} @else if ($preserve < 0) {
		@error 'Parameter `$preserve` holds value of `#{$preserve}` at mixin NECO. Value must be equal or greater than 0.';
	} @else if ($preserve > $length) {
		@error 'Parameter `$preserve` holds value of `#{$preserve}` at mixin NECO. Value must be equal or less than parameter `$length` which holds value `#{$length}`.';
	} @else if (math.round($preserve) != $preserve) {
		@error 'Parameter `$preserve` holds value of `#{$preserve}` at mixin NECO. Value must be an integer.';
	}
}

@mixin __ratio-errors($ratio) {
	@if (meta.type-of($ratio) == number) {
		@if ($ratio <= 1) {
			@error 'Parameter `$ratio` holds value of `#{$ratio}` at mixin NECO. Value must be greater than 1.';
		} @else if (math.is-unitless($ratio) != true) {
			@error 'Parameter `$ratio` at mixin NECO, must be a unitless number';
		}
	} @else if (meta.type-of($ratio) != number and meta.type-of($ratio) != string) {
		@error 'Parameter `$ratio` at mixin NECO, must be a type of number or string with one of these keys #{__map-keys($map-for-ratios)}.';
	} @else if (meta.type-of($ratio) == string) {
		@if (map.has-key($map-for-ratios, $ratio) != true) {
			@error 'Parameter `$ratio` holds value of `#{$ratio}` at mixin NECO. Value must be one of these keys #{__map-keys($map-for-ratios)}.';
		}
	}
}

@mixin __base-errors($base) {
	@if (meta.type-of($base) != number) {
		@error 'Parameter `$base` at mixin NECO, must be a type of number.';
	} @else if ($base < 0.1) {
		@error 'Parameter `$base` holds value of `#{$base}` at mixin NECO. Value must be equal or greater than 0.1.';
	} @else if (math.is-unitless($base)) {
		@error 'Parameter `$base` at mixin NECO, must be a number with unit.';
	}
}

@mixin generate-type-scale($config: null, $base: null, $ratio: null, $length: null, $preserve: 0, $utility-classes: true, $custom-values: null, $scale: 100%, $prefix: 'f-size-', $suffix: 'numeric', $prefix-class: null, $prefix-variable: null, $suffix-class: null, $suffix-variable: null) {

	@if ($config != null) {

		@each $key, $value in $config {
			@debug  $key;
			@if (meta.type-of($key) != string) {
				@error 'Parameter `$config` at mixin NECO, must be a type of map with keys of type of string.';
			}
		}


		$base                 : map.get($config, 'modular-scaling', 'base');
		$ratio                : map.get($config, 'modular-scaling', 'ratio');
		$length               : map.get($config, 'modular-scaling', 'length');
		$preserve             : if(map.get($config, 'modular-scaling', 'preserve') != null, map.get($config, 'modular-scaling', 'preserve'), 0);
		$utility-classes      : if(map.get($config, 'utility-classes') != null, map.get($config, 'utility-classes'), true);

		$custom-values        : map.get($config, 'custom-scaling', 'custom-values');
		$custom-values-length : list.length($custom-values);
		$scale                : if(map.get($config, 'custom-scaling', 'scale') != null, map.get($config, 'custom-scaling', 'scale'), 100%);

		$prefix               : if(map.get($config, 'naming-convention', 'prefix') != null, map.get($config, 'naming-convention', 'prefix'), 'f-size-');
		$prefix-class         : map.get($config, 'naming-convention', 'prefix-class');
		$prefix-variable      : map.get($config, 'naming-convention', 'prefix-variable');
		$suffix               : if(map.get($config, 'naming-convention', 'suffix') != null, map.get($config, 'naming-convention', 'suffix'), 'numeric');
		$suffix-class         : map.get($config, 'naming-convention', 'suffix-class');
		$suffix-variable      : map.get($config, 'naming-convention', 'suffix-variable');
	}

	@if ($base != null and $custom-values != null) {
		@error 'Invalide usage: Parameters `$base` and `$custom-values` at mixin NECO, cannot be used together.';
	} @else if ($ratio != null and $custom-values != null) {
		@error 'Invalide usage: Parameters `$ratio` and `$custom-values` at mixin NECO, cannot be used together.';
	} @else if ($length != null and $custom-values != null) {
		@error 'Invalide usage: Parameters `$length` and `$custom-values` at mixin NECO, cannot be used together.';
	} @else if ($preserve != 0 and $custom-values != null) {
		@error 'Invalide usage: Parameters `$preserve` and `$custom-values` at mixin NECO, cannot be used together.';
	}

	@if ($base != null and $scale != 100%) {
		@error 'Invalide usage: Parameters `$base` and `$scale` at mixin NECO, cannot be used together.';
	} @else if ($ratio != null and $scale != 100%) {
		@error 'Invalide usage: Parameters `$ratio` and `$scale` at mixin NECO, cannot be used together.';
	} @else if ($length != null and $scale != 100%) {
		@error 'Invalide usage: Parameters `$length` and `$scale` at mixin NECO, cannot be used together.';
	} @else if ($preserve != 0 and $scale != 100%) {
		@error 'Invalide usage: Parameters `$preserve` and `$scale` at mixin NECO, cannot be used together.';
	}

	@if ($base != null) {
		@include __base-errors($base);
	}
	@if ($ratio != null) {
		@include __ratio-errors($ratio);
	}
	@if ($length != null) {
		@include __length-errors($length);
	}
	@if ($preserve != 0) {
		@include __preserve-errors($preserve, $length);
	}
	@if ($utility-classes != true and $utility-classes != false) {
		@error 'Invalide type: Parameter `$utility-classes` at mixin NECO, must be a boolean.';
	}
	@if ($custom-values != null) {
		@if (meta.type-of($custom-values) != map) {
			@error 'Invalide type: Parameter `$custom-values` at mixin NECO, must be a map.';
		} @else if (meta.type-of($custom-values) == map and $prefix != 'f-size-') {
			@error 'Invalide usage: Parameters `$custom-values` and `$prefix` at mixin NECO, cannot be used together.';
		} @else if (meta.type-of($custom-values) == map and $prefix-class != null) {
			@error 'Invalide usage: Parameters `$custom-values` and `$prefix-class` at mixin NECO, cannot be used together.';
		} @else if (meta.type-of($custom-values) == map and $prefix-variable != null) {
			@error 'Invalide usage: Parameters `$custom-values` and `$prefix-variable` at mixin NECO, cannot be used together.';
		} @else if (meta.type-of($custom-values) == map and $suffix != 'numeric') {
			@error 'Invalide usage: Parameters `$custom-values` and `$suffix` at mixin NECO, cannot be used together.';
		} @else if (meta.type-of($custom-values) == map and $suffix-class != null) {
			@error 'Invalide usage: Parameters `$custom-values` and `$suffix-class` at mixin NECO, cannot be used together.';
		} @else if (meta.type-of($custom-values) == map and $suffix-variable != null) {
			@error 'Invalide usage: Parameters `$custom-values` and `$suffix-variable` at mixin NECO, cannot be used together.';
		}
		@each $key, $value in $custom-values {
			@if (meta.type-of($value) != number and meta.type-of($value) != string and meta.type-of($value) != boolean and meta.type-of($value) != map) {
				@error 'Invalide type: Parameter `$custom-values` at mixin NECO, must be a map with values of type number, string, boolean or map.';
			} @else if (meta.type-of($value) == string) {
				@if (string.length($value) < 1) {
					@error 'Invalide length: Parameter `$custom-values` at mixin NECO, must be a map with values of type string with length greater than 0.';
				}
			} @else if (meta.type-of($key) != string) {
				@error 'Invalide type: Parameter `$custom-values` at mixin NECO, must be a map with keys of type string.';
			} @else if (string.length($key) < 1) {
				@error 'Invalide length: Parameter `$custom-values` at mixin NECO, must be a map with keys of length greater than 0.';
			}
		}
	}
	@if ($scale) {
		@if (meta.type-of($scale) != 'number') {
			@error 'Invalide type: Parameter `$scale` at mixin NECO, must be a number.';
		} @else if (math.unit($scale) != '%') {
			@error 'Invalide unit: Parameter `$scale` at mixin NECO, must be a number with unit of %.';
		} @else if ($scale < 0) {
			@error 'Invalide value: Parameter `$scale` at mixin NECO, must be a number greater than 0.';
		}
	}
	@if ($prefix != null) {
		@include __prefix-errors($prefix);
	}
	@if ($prefix-class != null) {
		@include __prefix-errors($prefix-class);
	}
	@if ($prefix-variable != null) {
		@include __prefix-errors($prefix-variable);
	}
	@if ($suffix != 'numeric') {
		@include __suffix-errors($suffix);
	}
	@if ($suffix-class != null) {
		@include __suffix-errors($suffix-class);
	}
	@if ($suffix-variable != null) {
		@include __suffix-errors($suffix-variable);
	}

	$custom-values-length      : list.length($custom-values);
	$prefix-specified-class    : $prefix-class;
	$prefix-specified-variable : $prefix-variable;
	$suffix-specified-class    : $suffix-class;
	$suffix-specified-variable : $suffix-variable;
	$variable-prefix           : __set-prefix($prefix, $prefix-specified-variable); // Variable prefix based on called `$prefix` or `$prefix-variable` parameters. `$prefix-variable` have bigger priority than `$prefix`.

	////////////////////////////////////////
	// Checks if `$custom-values` is list.
	// List gives better options of easy/fast modification than map, because we can fast generate the prefix name or suffix, but it has own limitation.
	// By using list it's possible use custom values. Which gives more control of values rather than generated scalable values.
	@if (meta.type-of($custom-values) == list) {
		@for $i from 1 through list.length($custom-values) {
			$value           : __scale-number(list.nth($custom-values, $i), $scale); // Value of current `$i` in loop from list of custom values. The value is scaled based on `$scale` value. As default `$scale` is set to 100%.
			$hard-suffix     : $value;
			$variable-suffix : __set-suffix($suffix, $suffix-specified-variable, $custom-values-length, $hard-suffix, $i); // Variable suffix based on called `$suffix` or `$suffix-variable` parameters. `$suffix-variable` have bigger priority than `$suffix`.

			// !IMPORTANT! - The actual variable which is outputted. The variable is outputted based on `$prefix-variable`, `$suffix-variable` and `$value`.
			@include __variable-body($variable-prefix, $variable-suffix, $value);

			@if ($utility-classes) {
				$class-prefix : __set-prefix($prefix, $prefix-specified-class); // Class prefix based on called `$prefix` or `$prefix-class` parameters. `$prefix-class` have bigger priority than `$prefix`.
				$class-suffix : __set-suffix($suffix, $suffix-specified-class, $custom-values-length, $hard-suffix, $i); // Class suffix based on called `$suffix` or `$suffix-class` parameters. `$suffix-class` have bigger priority than `$suffix`.

				// !IMPORTANT! - The actual class which is outputted. The class is outputted based on `$prefix-class` and `$suffix-class`.
				@at-root .#{__class-body($class-prefix, $class-suffix)} {

					// !IMPORTANT! - The actual declaration line which is outputted. The declaration is outputted based on `$prefix-class` and `$suffix-class`.
					@include __declaration-body($variable-prefix, $variable-suffix);
				}
			}
		}

		////////////////////////////////////////
		// Checks if `$custom-values` is map.
		// Map gives more global usage. Means the same map can be used in different places throughout the code.
		// Map is easier to use than list, because it's not that abstracted away unlike list or generating scalable values.
		// The modification of map is unlimited, but changing values in map can be more repetitive and time consuming. List or generated scalable values have faster way of modification.
		// Like list by using map it's possible use custom values. Which gives more control of values rather than generated scalable
	} @else if (meta.type-of($custom-values) == map) {
		$map                      : $custom-values;

		@if (map.has-key($map, 'breakpoint-condition')) {
			$breakpoint-condition : map.get($map, 'breakpoint-condition');

			@if ($breakpoint-condition == 'min' or $breakpoint-condition == 'max') {
				@each $breakpoint, $map-values in $map {
					@if ($breakpoint == 'default') {
						@each $key, $value in $map-values {
							@if (meta.type-of($key) != string) {
								@error 'Invalide type: Parameter `$custom-values` at mixin NECO, must be a map with keys of type string.';
							} @else if (string.length($key) < 1) {
								@error 'Invalide length: Parameter `$custom-values` at mixin NECO, must be a map with keys of length greater than 0.';
							} @else if (meta.type-of($value) != number) {
								@error 'Invalide type: Outputted values must be type of number.';
							}

							$value    : __scale-number($value, $scale);

							--#{$key} : #{$value};

							@if (utility-classes) {
								// !IMPORTANT! - The actual class which is outputted. The class is outputted based on `$key`.
								@at-root .#{$key} {
									// !IMPORTANT! - The actual declaration line which is outputted. The declaration is outputted based on `$key`.
									font-size : var(--#{$key});
								}
							}
						}
					} @else {
						@include breakpoint($breakpoint-condition, $breakpoint) {
							@each $key, $value in $map-values {
								@if (meta.type-of($value) == number) {
									@if (meta.type-of($key) != string) {
										@error 'Invalide type: Parameter `$custom-values` at mixin NECO, must be a map with keys of type string.';
									} @else if (string.length($key) < 1) {
										@error 'Invalide length: Parameter `$custom-values` at mixin NECO, must be a map with keys of length greater than 0.';
									}

									$value    : __scale-number($value, $scale);

									--#{$key} : #{$value};
								}


							}
						}
					}

				}
			} @else {
				@error 'Invalide key value: `breakpoint-condition` must be either `min` or `max` not `#{$breakpoint-condition}`.';
			}

		} @else {

			@each $key, $value in $map {
				$value    : __scale-number($value, $scale); // Value of current `$key` in each loop from map of custom values. The value is scaled based on `$scale` value. As default `$scale` is set to 100%.

				//!IMPORTANT! - The actual variable which is outputted. The variable is outputted based on `$key` and `$value`.
				--#{$key} : #{$value};

				@if (utility-classes) {
					// !IMPORTANT! - The actual class which is outputted. The class is outputted based on `$key`.
					@at-root .#{$key} {
						// !IMPORTANT! - The actual declaration line which is outputted. The declaration is outputted based on `$key`.
						font-size : var(--#{$key});
					}
				}
			}

			@if ($config != null and map.has-key($config, 'breakpoint-condition')) {
				$breakpoint-condition : map.get($config, 'custom-scaling', 'breakpoint-condition');
				$breakpoints          : map.get($config, 'custom-scaling', 'breakpoints');

				@each $breakpoint-key, $breakpoint-map in $breakpoints {
					@include breakpoint($breakpoint-condition, $breakpoint-key) {
						@each $key, $value in $breakpoint-map {
							@debug $value;
							$value    : __scale-number($value, $scale); // Value of current `$key` in each loop from map of custom values. The value is scaled based on `$breakpoint-value` value. As default `$breakpoint-value` is set to 100%.

							//!IMPORTANT! - The actual variable which is outputted. The variable is outputted based on `$key` and `$value`.
							--#{$key} : #{$value};
						}
					}
				}
			}
		}


		////////////////////////////////////////
		// Generates scalable values.
		// Values are generated based on `$base`, `$ratio` and `$length` values.
		// Generating modular type scale is the fastest way of creating scalable sizes.
		// Easy to control with two properties, which is --base and --ratio css properties that can be modified any time and all the values will adjust to that.
		// By using `$preserve` parameter we can prevent the first values in type scale won't adjust. Good usage is for the smaller values like 0.5rem - 2rem that we don't want to adjust.
		//
	} @else {
		--#{$variable-prefix}base : #{$base}; // The base value, which is the first value in type scale and all the next values are generated from this value.

		// Checks if `$ratio` is string.
		//`$ratio` parameter can be number or string
		@if (meta.type-of($ratio) == string) {
			$ratio  : map.get($map-for-ratios, $ratio); // If `$ratio` is string, then check in the `$map-for-ratios`, which ratio to use.
			--ratio : #{$ratio}; // Outputs the ratio number value.
		} @else {
			--ratio : #{$ratio}; // Else just output the `$ratio` based on the parameter.
		}

		// Loop over the `$length` parameter and generate from that number the scalable values.
		@for $i from 1 through $length {
			$hard-suffix     : 'none'; // Hard suffix is disabled. In my opinion with scalable values wouldn't be good idea to have hard suffix values.
			$variable-suffix : __set-suffix($suffix, $suffix-specified-variable, $length, $hard-suffix, $i); // Variable suffix based on called `$suffix` or `$suffix-variable` parameters. `$suffix-variable` have bigger priority than `$suffix`.

			// Checks if there will be any value preserved.
			@if ($preserve == 0) {

				// At first iteration in the loop
				@if ($i == 1) {
					// !IMPORTANT -  The actual value which is outputted. Calculating the `$base` value with `$ratio`.
					$value                  : calc(var(--#{$variable-prefix}base) * var(--ratio));

					// !IMPORTANT! - The actual variable which is outputted. The variable is outputted based on `$variable-prefix`, variable-suffix` and `$value`.
					@include __variable-body($variable-prefix, $variable-suffix, $value);

					// In next iterations
				} @else {
					$variable-suffix-before : __set-suffix($suffix, $suffix-specified-variable, $length, $hard-suffix, $i - 1); // Variable suffix from the previous iteration. So we can chain all the values and generate the scalable values.

					// !IMPORTANT -  The actual value which is outputted. Calculating the previous variable value with `$ratio`.
					$value                  : calc(var(--#{$variable-prefix}#{$variable-suffix-before}) * var(--ratio));

					// !IMPORTANT! - The actual variable which is outputted. The variable is outputted based on `$variable-prefix`, variable-suffix` and `$value`.
					@include __variable-body($variable-prefix, $variable-suffix, $value);
				}

				// If utility classes are true do as mentioned above.
				@if ($utility-classes) {
					$class-prefix : __set-prefix($prefix, $prefix-specified-class);
					$class-suffix : __set-suffix($suffix, $suffix-specified-class, $length, $hard-suffix, $i);

					@at-root .#{__class-body($class-prefix, $class-suffix)} {
						@include __declaration-body($variable-prefix, $variable-suffix);
					}
				}

				// Else if there are any values which has to be preserved.
			} @else {

				// At first iteration in the loop
				@if ($i == 1) {
					// !IMPORTANT -  The actual value which is outputted. By using `__get-value` function.
					$value                  : __get-value($base, $ratio, $preserve, $i, $variable-prefix);

					// !IMPORTANT! - The actual variable which is outputted. The variable is outputted based on `$variable-prefix`, variable-suffix` and `$value`.
					@include __variable-body($variable-prefix, $variable-suffix, $value);

					// In next iterations
				} @else {
					$variable-suffix-before : __set-suffix($suffix, $suffix-specified-variable, $length, $hard-suffix, $i - 1); // Variable suffix from the previous iteration. So we can chain all the values and generate the scalable values.

					// !IMPORTANT -  The actual value which is outputted. By using `__get-value` function.
					$value                  : __get-value($base, $ratio, $preserve, $i, $variable-prefix, $variable-suffix-before);

					// !IMPORTANT! - The actual variable which is outputted. The variable is outputted based on `$variable-prefix`, variable-suffix` and `$value`.
					@include __variable-body($variable-prefix, $variable-suffix, $value);
				}

				// If utility classes are true do as mentioned above.
				@if ($utility-classes) {
					$class-prefix : __set-prefix($prefix, $prefix-specified-class);
					$class-suffix : __set-suffix($suffix, $suffix-specified-class, $length, $hard-suffix, $i);

					@at-root .#{__class-body($class-prefix, $class-suffix)} {
						@include __declaration-body($variable-prefix, $variable-suffix);
					}
				}
			}
		}
	}
}


$map-ff    : (
		'breakpoint-condition': 'max',
		'default' : (
				'f-size-1' : 1rem,
				'f-size-2' : 1.5rem,
				'f-size-3' : 2rem,
				'f-size-4' : 2.5rem,
				'f-size-5' : 3rem,
				'f-size-6' : 3.5rem,
				'f-size-7' : 4rem,
				'f-size-8' : 5rem,
				'f-size-9' : 6rem,
				'f-size-10' : 8rem,
		),
		'tablet-md' : (
				'f-size-7' : #333333,
				'f-size-8' : 3rem,
				'f-size-9' : 4rem,
				'f-size-10' : 5rem,
		),
		'tablet-min' : (
				'f-size-9' : 3rem,
				'f-size-10' : 1rem,
		),
);

$map-f     : (
		'f-size-1' : 2,
		'f-size-2' : 1.5,
		'f-size-3' : 2,
		'f-size-4' : 2.5,
		'f-size-5' : 3,
		'f-size-6' : 3.5rem,
		'f-size-7' : 4,
		'f-size-8' : 5,
		'f-size-9' : 6,
		'f-size-10' : 7,
);

$map-fmin  : (
		'f-size-7' : 4,
		'f-size-8' : 3,
		'f-size-9' : 4,
		'f-size-10' : 5,
);

$map-fmin2 : (
		'f-size-9' : 3,
		'f-size-10' : 55,
);

//
//$config : (
//		'utility-classes' : 1,
//		'modular-scaling' : (
//				'base' : 1rem,
//				'ratio' : 'major-second',
//				'length' : 10,
//				'preserve' : 5,
//		),
//);

//$config    : (
//		'custom-scaling' : (
//				'custom-values' : $map-f,
//				'breakpoint-condition' : max,
//				'breakpoints': (
//						'tablet-md' : $map-fmin,
//						'tablet-min' : $map-fmin2,
//				),
//		)
//);

$config    : (
		'' : (
				'custom-values' : $map-ff,
				'scale' : 50%,
		)
);

$config : (
		'' : (
				'base' : 1rem,
				'ratio' : 'major-second',
				'length' : 10,
				'preserve' : 5,
		),
);


:root {
	@include generate-type-scale($config);
	//@include generate-type-scale($custom-values : $map-f, $scale : 100%);
	//@include generate-type-scale($base : 2rem, $ratio : 'major-second', $length : 9, $prefix: 'text-', $suffix-variable: 'size-and-x-minmax');

	@include breakpoint(max, 1000px) {
	}
}























