@charset "UTF-8";

/**
 * Mixin outputs a declaration based on given parameters.
 *
 * @author - Martin Kamír
 *
 */
@mixin _declaration-shell($prefix, $suffix, $value, $selector, $key: null) {
	@if $selector == 'none' and ($key == 'fluid-space-types' or $key == 'space-types') {
		--space      : var(--#{$prefix}#{$suffix});
	} @else {
		#{$selector} : var(--#{$prefix}#{$suffix});
	}
}

/**
 * Mixin outputs utility classes for color and background properties.
 *
 * @author - Martin Kamír
 *
 */
@mixin _generate-color-utilities($utility-classes, $prefix-text, $prefix-background, $key, $suffix, $value) {
	@if $utility-classes {
		@at-root .#{$prefix-text}#{$key}#{$suffix} {
			@include _declaration-shell($key, $suffix, $value, 'color');
		}
		@at-root .#{$prefix-background}#{$key}#{$suffix} {
			@include _declaration-shell($key, $suffix, $value, 'background-color');
		}
	}
}

/**
 * Mixin for generating the color values.
 *
 * @author - Martin Kamír
 *
 */
@mixin _generate-colors($config, $map, $enabled-classes) {
	$tints             : map-get($config, 'tints');
	$shades            : map-get($config, 'shades');
	$hsl-formatting    : map-get($config, 'hsl');
	$prefix-text       : map-get($config, 'prefix-text');
	$prefix-background : map-get($config, 'prefix-background');
	$suffix            : map-get($config, 'suffix');
	$suffix            : map-get($config, 'suffix');
	$utility-classes   : map-get($config, 'utility-classes');

	// If $enabled-classes is false then the $utility-classes will be false too, This statement is used to avoid generating the same utility classes but for a dark or light color scheme.
	@if $enabled-classes == false {
		$utility-classes : false;
	}

	$_suffix           : '';
	$colors-list       : ();

	@each $key, $value in $map {

		// Mechanism for generating the color properties with a suffix that relies on a number-based list of suffixes. Such as 'roman', 'nato', 'numeric', 'numeric-hundreds', custom list of suffixes, etc.
		@if $suffix != null and $suffix != 'color-adjectives' {

			// If tints are defined then based on the percentage values of tints get the value and append it to the colors-list.
			@if $tints != null {
				@for $x from 1 through length($tints) {
					$_value      : _get-hsl(mix(white, $value, nth($tints, $x)), $hsl-formatting);
					$colors-list : append($colors-list, $_value);
				}
			}

			// Get the default value from the $src map. Append it to the colors-list in middle. So the tints will be at the start default value at the middle and the shades at the end.			// Get the default value from the $src map. Append it to the colors-list at middle. So the tints will be at start default value at the middle and the shades at the end.
			$_value      : _get-hsl($value, $hsl-formatting);
			$colors-list : append($colors-list, $_value);

			// If shades are defined then based on the percentage values of shades get the value and append it to the colors-list.
			@if $shades != null {
				@for $x from 1 through length($shades) {
					$_value      : _get-hsl(mix(black, $value, nth($shades, $x)), $hsl-formatting);
					$colors-list : append($colors-list, $_value);
				}
			}

			// Loop for outputting the color values from the colors-list and generating the utility classes.
			@for $x from 1 through length($colors-list) {
				$_suffix : '-#{_get-suffix($suffix, length($colors-list), $x)}';
				$value   : nth($colors-list, $x);

				@include _variable-shell($key, $_suffix, $value);
				@include _generate-color-utilities($utility-classes, $prefix-text, $prefix-background, $key, $_suffix, $value);
			}
		}

		// Mechanism for generating the color properties with 'color-adjectives' suffix.
		@if $suffix == 'color-adjectives' {

			// Generate tint color properties and utility classes.
			@if $tints != null {
				@for $x from 1 through length($tints) {
					$_value  : _get-hsl(mix(white, $value, nth($tints, $x)), $hsl-formatting);
					$_suffix : '-#{_get-suffix($suffix, length($tints), $x, 'lighter-values')}';

					@include _variable-shell($key, $_suffix, $_value);
					@include _generate-color-utilities($utility-classes, $prefix-text, $prefix-background, $key, $_suffix, $value);
				}
			}

			// Generate the default color properties and utility classes.
			$_value  : _get-hsl($value, $hsl-formatting);
			$_suffix : '';

			@include _variable-shell($key, $_suffix, $_value);
			@include _generate-color-utilities($utility-classes, $prefix-text, $prefix-background, $key, $_suffix, $value);

			// Generate shade color properties and utility classes.
			@if $shades != null {
				@for $x from 1 through length($shades) {
					$_value  : _get-hsl(mix(black, $value, nth($shades, $x)), $hsl-formatting);
					$_suffix : '-#{_get-suffix($suffix, length($shades), $x, 'darker-values')}';

					@include _variable-shell($key, $_suffix, $_value);
					@include _generate-color-utilities($utility-classes, $prefix-text, $prefix-background, $key, $_suffix, $value);
				}
			}
		}

		// Mechanism for generating the color properties with no suffix. Mainly used for generating the color pallet from $src.
		@if $suffix == null {
			@include _variable-shell($key, $_suffix, $value);
			@include _generate-color-utilities($utility-classes, $prefix-text, $prefix-background, $key, $_suffix, $value);
		}

		// At the end of the loop, clear the colors-list. To avoid generating the same color properties again.
		$colors-list : ();
	}
}

/**
 * Generates css properties of given parameters in config.
 *
 * NOTE: This function is main building block for the generated types scale functionality, which controls generating the css properties.
 *
 * @author - Martin Kamír
 *
 */
@mixin _generate-types-scale($config) {

	// Getting all the values from the config map.
	$key             : map-get($config, 'key');
	$selector        : map-get($config, 'selector');
	$base            : map-get($config, 'base');
	$ratio           : map-get($config, 'ratio');
	$length          : map-get($config, 'length');
	$preserve        : map-get($config, 'preserve');
	$utility-classes : map-get($config, 'utility-classes');
	$src             : map-get($config, 'src');
	$src             : map-get($config, 'src');
	$break-at        : map-get($config, 'break-at');
	$breakpoints     : map-get($config, 'breakpoints');
	$scale           : map-get($config, 'scale');
	$prefix          : map-get($config, 'prefix');
	$prefix-class    : map-get($config, 'prefix-class');
	$prefix-variable : map-get($config, 'prefix-variable');
	$suffix          : map-get($config, 'suffix');
	$suffix-class    : map-get($config, 'suffix-class');
	$suffix-variable : map-get($config, 'suffix-variable');

	// Sets all variables to be used in the mixin.
	$src-length      : length($src);
	$src-type        : type-of($src);
	$ratio           : _validate-ratio($ratio);
	$prefix          : _get-name($prefix, $prefix-variable);
	$suffix          : _get-name($suffix, $suffix-variable);
	$_suffix         : null;
	$_prefix         : null;
	$keys            : null;
	$suffix-prev     : null;
	$value           : null;
	$length          : if($length != null, $length, $src-length);

	// If base is used generate the base and ratio css properties with a given prefix.
	@if $base != null {
		--#{$prefix}ratio : #{$ratio};
		--#{$prefix}base  : #{$base};
	}

	// If $src is a map convert keys and values to a list and set the values length variable.
	@if $src-type == map {
		$keys       : to-list($src, 'keys');
		$src        : to-list($src, 'values');
		$src-length : length($src);
	}

	// Main loop for generating the css properties.
	@for $i from 1 through $length {
		// Shallow copies of $suffix and $prefix variables.
		$_prefix : _get-name($prefix, $prefix-variable); // Get the prefix name.
		$_suffix : _get-suffix($suffix, $length, $i); // Get the suffix for the current iteration.

		// If $base is used
		@if $base != null {
			$value : calc(var(--#{$prefix}base) * var(--#{$prefix}ratio)); // In first iteration output calculation of the base value multiplied by the ratio.

			// In other iterations calculate the base value multiplied by the ratio and use the previous value.
			@if $i > 1 {
				$suffix-prev : _get-suffix($suffix, $length, $i - 1); // Get the suffix for the previous iteration.
				$value       : calc(var(--#{$prefix}#{$suffix-prev}) * var(--#{$prefix}ratio)); // Output the calculation of value which is based on $prefix and $suffix-prev multiplied by the ratio.
			}

			// If $preserve is used get the value by _get-value function.
			@if $preserve > 1 {
				$value : _get-value($base, $ratio, $preserve, $i, $prefix);

				@if $i > 1 {
					$value : _get-value($base, $ratio, $preserve, $i, $prefix, $suffix-prev);
				}
			}
		}

		// If $src is a list or map
		@if $src-type == list or $src-type == map {
			$_suffix : _get-suffix($suffix, $src-length, $i);
			$value   : _number-scale(nth($src, $i), $scale); // Get the value from the list at the current iteration and scale it if used.
		}

		// If $src is a map
		@if $src-type == map {
			$_prefix : nth($keys, $i); // Get the key from the list at the current iteration.
			$_suffix : ''; // Because the map is used the suffix is empty. The key is used as the prefix and suffix.
		}

		// The actual css property which is outputted.
		@include _variable-shell($_prefix, $_suffix, $value);

		//If utility-classes are set to true generate the utility classes based on the prefix, suffix, value and selector.
		@if $utility-classes {
			$class-prefix : if($src-type == map, $_prefix, _get-name($prefix, $prefix-class));
			$class-suffix : if($src-type == map, $_suffix, _get-suffix(_get-name($suffix, $suffix-class), $length, $i));

			@at-root .#{_class-shell($class-prefix, $class-suffix)} {
				@include _declaration-shell($_prefix, $_suffix, $value, $selector, $key);
			}
		}
	}

	// If $break-at is used generate breakpoints with css properties.
	@if ($breakpoints != null) {
		@for $i from 1 through length($breakpoints) {
			$breakpoint : nth(nth($breakpoints, $i), 1); // Get the breakpoint value.
			$src        : nth(nth($breakpoints, $i), 2); // Get the src value.
			$src-type   : type-of(nth(nth($breakpoints, $i), 2)); // Get the src type.

			// If $src is a map convert keys and values to a list.
			@if $src-type == map {
				$keys : to-list($src, 'keys');
				$src  : to-list($src, 'values');
			}

			// The actual outputted breakpoint
			// The $break-at value must be one of the breakpoints in $map-for-breakpoints.
			@include breakpoint($break-at, $breakpoint) {
				$x : 1; // Second iteration of the loop.
				$y : $src-length - length($src) + 1; // Third iteration of the loop. Which starts by getting the difference between the length of the src and the length of the main loop current iteration.

				@while $y <= $src-length {
					$_prefix : _get-name($prefix, $prefix-variable); // Get the prefix name.
					$_suffix : _get-suffix($suffix, $src-length, $y); // Get the suffix for the current iteration of $y.
					$value   : _number-scale(nth($src, $x), $scale); // Get the value from the list at the current iteration of $x and scale it if used.

					// If $src is a map
					@if $src-type == map {
						$_prefix : nth($keys, $x); // Get the key from the list at the current iteration.
						$_suffix : ''; // Since the map is used the suffix is empty, because the key is used as the prefix and suffix.

						// If the key is ratio
						@if $_prefix == 'ratio' {
							$_prefix : $prefix; // Use the prefix instead of the key.
							$_suffix : 'ratio'; // Use string 'ratio' as the suffix.
							$value   : _validate-ratio(nth($src, $x)); // Validate the ratio and get the value.
						}

						// If the key is base
						@if $_prefix == 'base' {
							$_prefix : $prefix; // Use the prefix instead of the key.
							$_suffix : 'base'; // Use string 'base' as the suffix.
						}
					}

					// The actual css property which is outputted in the breakpoint.
					@include _variable-shell($_prefix, $_suffix, $value);

					// At the end of the loop increment $x and $y.
					$y       : $y + 1;
					$x       : $x + 1;
				}
			}
		}
	}
}

/**
 * Mixin for processing the color parameters.
 *
 * @author - Martin Kamír
 *
 */
@mixin _process-colors($config) {
	$src              : map-get($config, 'src');
	$src-scheme       : map-get($config, 'src-scheme');
	$preferred-scheme : map-get($config, 'preferred-scheme');
	$dark-scheme      : false;
	$map              : $src;

	// The main loop for processing and outputting the colors.
	@for $i from 1 through if($src-scheme == null, 1, 2) {

		// Switching the map to the preferred color scheme.
		@if length($src) == 1 {
			@if $src-scheme != null and $i > length($map) {
				$map         : $src-scheme;
				$dark-scheme : true;
			}
		} @else {
			@if $src-scheme != null and $i >= length($map) {
				$map         : $src-scheme;
				$dark-scheme : true;
			}
		}

		// Generating the color properties to the root and at media preferred color scheme.
		@if $dark-scheme == false {
			@include _generate-colors($config, $map, true);
		} @else {
			@media (prefers-color-scheme : #{$preferred-scheme}) {
				@include _generate-colors($config, $map, false);
			}
		}
	}
}

/**
 * Process config map or parameters into one main config map, which will be disturbed to other functions to
 * generate scalable css properties, based on given parameters/config.
 *
 * NOTE: This function is a building block for the generated scalable system functionality.
 *
 * @author - Martin Kamír
 *
 */
@mixin _process-config($config: null, $key: null, $selector: null, $base: null, $ratio: null, $length: null, $preserve: 0, $utility-classes: true, $src: null, $scale: 100%, $prefix: null, $suffix: null, $prefix-class: null, $prefix-variable: null, $suffix-class: null, $suffix-variable: null) {

	// Make shallow copy config map from parameters.
	$_config : (
			'key': $key,
			'selector' : $selector,
			'base' : $base,
			'ratio' : $ratio,
			'length' : $length,
			'preserve' : $preserve,
			'utility-classes' : $utility-classes,
			'src' : $src,
			'scale' : $scale,
			'prefix' : $prefix,
			'suffix' : $suffix,
			'prefix-class' : $prefix-class,
			'prefix-variable' : $prefix-variable,
			'suffix-class' : $suffix-class,
			'suffix-variable' : $suffix-variable,
			'break-at' : 'max',
	);

	// If config parameter is used validate it and merge it into shallow copy config map.
	@if $config != null {
		$_config : map.deep-merge($_config, _validate-config-map($config, $key));
	}

	// Validate config map and after init generating the css properties.
	@include _validate-config($_config);
	@include _generate-types-scale($_config)
}

/**
 * Validates config
 *
 * NOTE: This function is helper function for _process-config function.
 *
 * @author - Martin Kamír
 *
 */
@mixin _validate-config($config) {

	// Get config keys
	$key               : map-get($config, 'key');
	$base              : map-get($config, 'base');
	$ratio             : map-get($config, 'ratio');
	$length            : map-get($config, 'length');
	$preserve          : if(map-get($config, 'preserve') == null, 0, map-get($config, 'preserve'));
	$utility-classes   : map-get($config, 'utility-classes');
	$src               : map-get($config, 'src');
	$src-scheme        : map-get($config, 'src-scheme');
	$break-at          : map-get($config, 'break-at');
	$breakpoints       : map-get($config, 'breakpoints');
	$scale             : map-get($config, 'scale');
	$prefix            : map-get($config, 'prefix');
	$prefix-class      : map-get($config, 'prefix-class');
	$prefix-variable   : map-get($config, 'prefix-variable');
	$prefix-text       : map-get($config, 'prefix-text');
	$prefix-background : map-get($config, 'prefix-background');
	$suffix            : map-get($config, 'suffix');
	$suffix-class      : map-get($config, 'suffix-class');
	$suffix-variable   : map-get($config, 'suffix-variable');
	$hsl-formatting    : map-get($config, 'hsl-formatting');
	$tints             : map-get($config, 'tints');
	$shades            : map-get($config, 'shades');
	$preferred-scheme  : map-get($config, 'preferred-scheme');

	// Preventing $base, $ratio, $length and $preserve to be used together with $src and $scale.
	// The reason behind this is we don't want generate ratio scaled values with custom values from map or list.
	@if ($base != null or $ratio != null or $length != null or $preserve != 0) and
		($src != null  or $scale != 100%) {
		@error "Invalid set of parameters: 'base', 'ratio', 'length', 'preserve' AND 'src', 'break-at', 'breakpoints', 'scale' are mutually exclusive.";
	}

	// Prevent parameters to have incorrect type values i.g $base parameter being a color type or $utility-classes parameter being string type and so on...
	@if (type-of($base) != 'null' and type-of($base) != number and type-of($base) != calculation) or
		 (type-of($ratio) != 'null' and type-of($ratio) != string and type-of($ratio) != number) or
		 (type-of($length) != 'null' and type-of($length) != number) or
		 (type-of($utility-classes) != bool) or
		 (type-of($src) != 'null' and type-of($src) != map and type-of($src) != list and type-of($src) != arglist and type-of($src) != number) or
		 (type-of($src-scheme) != 'null' and type-of($src-scheme) != map and type-of($src-scheme) != list and type-of($src-scheme) != arglist and type-of($src-scheme) != number) or
		 (type-of($break-at) != 'null' and type-of($break-at) != string) or
		 (type-of($breakpoints) != 'null' and type-of($breakpoints) != map) or
		 (type-of($scale) != 'null' and type-of($scale) != number) or
		 (type-of($tints) != 'null' and type-of($tints) != list) or
		 (type-of($hsl-formatting) != 'null' and type-of($hsl-formatting) != string) or
		 (type-of($preferred-scheme) != 'null' and type-of($preferred-scheme) != string) or
		 (type-of($shades) != 'null' and type-of($shades) != list) or
		 (type-of($prefix) != 'null' and type-of($prefix) != string) or
		 (type-of($prefix-class) != 'null' and type-of($prefix-class) != string) or
		 (type-of($prefix-variable) != 'null' and type-of($prefix-variable) != string) or
		 (type-of($prefix-text) != 'null' and type-of($prefix-text) != string) or
		 (type-of($prefix-background) != 'null' and type-of($prefix-background) != string) or
		 (type-of($suffix) != 'null' and type-of($suffix) != string and type-of($suffix) != list) or
		 (type-of($suffix-class) != 'null' and type-of($suffix-class) != string and type-of($suffix-class) != list) or
		 (type-of($suffix-variable) != 'null' and type-of($suffix-variable) != string and type-of($suffix-variable) != list) {
		@error 'Invalid type value: check if values hold the corresponding type.';
	}

	// Prevent $base and $scale values to be below 0.
	@if (type-of($base) != calculation and (type-of($base) != 'null' and $base < 0)) or (type-of($scale) != 'null' and $scale < 0) {
		@error "Invalid value: 'base', 'length', 'scale' must be greater than or equal to 0.";
	}

	// Prevent $base value to be unitless number.
	@if type-of($base) != calculation and (type-of($base) != 'null' and unitless($base)) {
		@error "Invalid value: 'base' must be a number with a unit.";
	}

	// Prevent $ratio, $length and $preserve values to be number with unit.
	@if (type-of($ratio) != string and type-of($ratio) != 'null' and unitless($ratio) != true) or
		(unitless($preserve) != true) or
		(type-of($ratio) != 'null' and unitless($length) != true) {
		@error "Invalid value: 'ratio', 'preserve', 'length' must be a number with no unit.";
	}

	// Prevent $preserve and $length values to be decimal numbers.
	@if round($preserve) != $preserve or (type-of($ratio) != 'null' and round($length) != $length) {
		@error "Invalid value: 'preserve', 'length' must be an integer.";
	}

	// If $ratio is type of string check for the corresponding ratio type.
	@if (type-of($ratio) != number) and type-of($ratio) != 'null' and map-has-key($map-for-ratios, $ratio) != true {
		@error "Invalid value: 'ratio' must be one of #{_map-keys($map-for-ratios)}.";
	}

	// Prevent $preserve value being greater than $length.
	@if type-of($ratio) != 'null' and ($preserve > $length) {
		@error "Invalid value: 'preserve' must be less than or equal to 'length'.";
	}

	// Prevent $length value being greater than 40 or less than 1.
	@if (type-of($ratio) != 'null') and ($length > 40 or $length < 1) {
		@error "Invalid value: 'length' must be between 1 and 40.";
	};

	// Prevent $scale value to have a different unit than percentage.
	@if (type-of($scale) != number and (type-of($scale) != 'null' and unit($scale) != '%')) {
		@error "Invalid value: 'scale' must be a percentage.";
	}

	// Prevent $break-at value to be different than 'max' or 'min'.
	@if ($break-at != null and $break-at != 'min' and $break-at != 'max') {
		@error "Invalid value: 'break-at' must be 'min' or 'max'.";
	}

	// Warn if $preserve or $scale will be used in.
	@if ($key == 'fluid-space-types' or $key == 'fluid-font-types') and ($preserve != 0 or $scale != 100%) {
		@warn "Invalid set of parameters: 'preserve' and 'scale' are not applicable to 'fluid-space-types' and 'fluid-font-types' respectively.";
	}

	// Prevent $preferred-scheme value to be different than 'dark' or 'light'.
	@if ($preferred-scheme != null) and ($preferred-scheme != 'dark' and $preferred-scheme != 'light') {
		@error "Invalid value: 'preferred-scheme' must be 'dark' or 'light'.";
	}

	// Prevent $hsl-formatting value to be different than 'function' or 'numbers'.
	@if ($hsl-formatting != null) and ($hsl-formatting != 'function' and $hsl-formatting != 'numbers') {
		@error "Invalid value: 'hsl-formatting' must be 'function' or 'numbers'.";
	}

	// Validate the config keys.
	@include _validate-config-keys($config, $key);
}

/**
 * Checks if used keys in config map are valid.
 *
 * NOTE: This function is helper function for _validate-config-parameters function.
 *
 * @author - Martin Kamír
 *
 */
@mixin _validate-config-keys($map, $key) {
	$map-key    : $key;
	$valid-keys : ();
	$keys       : ();

	@if $map-key == 'color-types' {
		$valid-keys : ('key', 'src', 'src-scheme', 'tints', 'shades', 'hsl-formatting', 'utility-classes', 'prefix-text', 'prefix-background', 'suffix', 'preferred-scheme');
	} @else if ($map-key == 'fluid-font-types' or $map-key == 'fluid-space-types' or $map-key == 'font-types' or $map-key == 'space-types') {
		$valid-keys : ('key', 'selector', 'base', 'ratio', 'length', 'preserve', 'utility-classes', 'src', 'scale', 'prefix', 'suffix', 'prefix-class', 'prefix-variable', 'suffix-class', 'suffix-variable', 'break-at', 'breakpoints');
	} @else {
		@error 'Invalid key in config map: key must be one of the following: color-types, fluid-font-types, fluid-space-types, font-types, space-types';
	}

	@each $key, $value in $map {
		$keys : append($keys, $key);

		// Check if value is a map.
		@if type-of($value) == map {
			$map : map.deep-remove($map, $value); // Remove nested map.
			$map : map-merge($map, $value); // Merge removed map to current scope in main map.
		}

		// Loop over new map and check if keys are string and at least 1 character long.
		@each $key, $value in $map {
			@if type-of($key) != string {
				@error "Invalid key '#{$key}': all keys must be a string in the map.";
			} @else if length($key) < 1 {
				@error "Invalid key length: all keys must be at least 1 character in the map.";
			}
		}
	}


	// Loop over keys lists and check if all keys are valid.
	@for $i from 1 through length($keys) {
		@for $x from 1 through length($valid-keys) {
			@if index($valid-keys, nth($keys, $i)) == null {
				@error "Invalid parameter '#{nth($keys, $i)}': parameters must be one of these: #{$valid-keys}.";
			};
		}
	}
}

/**
 * Mixin outputs a css custom property.
 *
 * @author - Martin Kamír
 *
 */
@mixin _variable-shell($prefix, $suffix: null, $value) {
	--#{$prefix}#{$suffix} : #{$value};
}
